

class UbootGame {

    static UbootGame instance;
    field Background background;
    field Sub sub;
    field Torpedo torpedo;
    field boolean exit;
    field int seed; // with [-32 768, 32 767]

    constructor UbootGame new() {
        // Clear the screen
        do Screen.clearScreen();
        let background = Background.new();
        let sub = Sub.new(background.getTop(), background.getBot());
        let seed = 1; 
        let torpedo = generateTorpedo(background);
        let exit = false;
        return this;
    }

    // TODO: we also need a torpedo de-generator here (hide and disposes at left X-limit)
    // ... We set a torpGone bool, which could be fed into this one along 
    //     with the torpedo object
    // Isnt this fixed by the torp.move() disposing of the torp??

    /** Deallocates the object's memory. */
    method void dispose() {
        do background.dispose();
	    do sub.dispose();
        do Memory.deAlloc(this);
        return;
    }

    /** Creates an instance of a UbootGame. */
    function void newInstance() {
        let instance = UbootGame.new();
        return;
    }

    /** Returns this UbootGame. */
    function PongGame getInstance() {
        return instance;
    }

    method Torpedo generateTorpedo (Background background) {
        var Torpedo torpedoVar;
        let seed = updateSeed(seed*32, background.getTop(), background.getBot());
        let torpedoVar = Torpedo.new(seed, background);
        return torpedoVar;
    }

    method int updateSeed(int seed, int backgroundTop, int backgroundBot) {
        var int sizeY;
        var int quotient;
        var int remainder;
        // Using a Linear Congruential Generator
        // 1. Update Seed
        // seed = (a * seed + c) mod m
        let seed = (5 * seed) + 11;

        // Modulo operator keeps us within specified range
        // ... What is the specified range?
        // ... We know that the generated value must be multiplied
        // ... with (32) to generate a different row. 
        // ... The background_top/bot sets the boundary for which we 
        // ... are allowed to spawn. We also need to take into account
        // ... that the sprite occupies white space.
        // 
        let sizeY = (backgroundBot - backgroundTop)/32 + 1; // should this be divided by 32?
        // Integer quotient
        let quotient = seed / sizeY;
        // Remainder = 0 if common divisor, otherwise think modulo operation
        let remainder = quotient * sizeY;  
        // Update seed
        let seed = seed - remainder;
        // TODO might have to confine the lil guy here if shit hits the fan
        return seed;
    }


    /** Starts the game, and handles inputs from the user that control
     *  the sub's movement direction. */
    method void run() {
        var char key;
        var boolean torpedoOOB;

        while (~exit) {
            // waits for a key to be pressed (key = 0 is default non-press)
            // TODO: fix this? Could increase the wait-counter and skip the while conditions totally
            do Sys.wait(250);
            let key = Keyboard.keyPressed();
            
            // -------------------------------------------------
            // TODO: Check for collisions
            // How?
            // We know how to calculate when torpedo is @ X-limit.
            // Then we just check if @ X-limit and Y_sub_top <= Y_torp <= Y_sub_bot
            // If true, then collision, set exit to TRUE!!
            
            let exit = torpedo.collision(sub.getTop(), sub.getBot());
            

            // -------------------------------------------------
            // Torpedo movement and collision check
            // Note: Torpedo.move() will also dispose of the torpedo
            let torpedoOOB = torpedo.move();

            if (torpedoOOB) {
                // Torpedo has hit X-limit and is out-of-bounds
                // ... Generate new torpedo object
                // TODO: this shit activates straight away. why??
                let torpedo = generateTorpedo(background);
                //let exit = true;
            }
            else {
                let exit = torpedo.collision(sub.getTop(), sub.getBot()); 
                //let exit = false;
            }
            // -------------------------------------------------
            // Key press parsing
            if (key = 131) { 
                do sub.move(1);
            } 
	        if (key = 133) { 
                do sub.move(0);
            }
            // key = 130 is escape
            if (key = 140) { 
                let exit = true; 
            }
            
            let key = Keyboard.keyPressed();
        }

	    if (exit) {
            do Output.moveCursor(10,27);
	        do Output.printString("Game Over");
	    }
            
        return;
    }

}